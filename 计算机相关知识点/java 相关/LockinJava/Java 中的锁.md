# 重量级锁

内置锁在Java中被抽象为**监视器锁（monitor）**，同步成本非常高（包括系统调用引起的 内核态和用户态切换，线程阻塞造成的线程切换），后来又改称为**重量级锁**

# 自旋锁

对于上面提到的两个问题：内核态和用户态的切换这方面不好优化，而对于第二点，自旋锁 可以减少线程阻塞造成的线程切换

如果锁的粒度比较小，那么锁持有的时间比较短，具体如下：
- 当前线程竞争锁失败，instead of 阻塞自己，而是自旋（空等待）一会
- 在自旋的同时继续竞争锁
- 如果自旋结束前获得了锁，则成功；不然就阻塞自己

> 那么为什么说自旋锁减少了线程切换呢？
> 
> 因为如果在自旋的时间内，锁被原来的owner释放了（即自旋锁等到了），那当前线程就不用阻塞自己了，这就减少了一次线程切换

## 缺点

- 单核处理器上，不存在实际的并行，如果当前线程不阻塞自己，原有owner就不能执行，锁也就永远不会释放；另一方面，如果线程多而处理器少，自旋也会造成不少浪费
- 自旋锁要占用CPU，如果是计算密集型任务，自旋锁得不偿失，还不如减少锁的使用
- 如果锁竞争的时间比较长，那么自旋通常就没用，白白浪费自旋占用的CPU时间（即，如果竞争激烈，锁持有时间长，应当禁用自旋锁）

# 自适应自旋锁

自适应的意思是 **自选时间不再固定**，而是由前一次在同一个锁上的自旋时间及锁的拥有者来决定：
- 如果在同一个锁对象上，之前通过自旋方式获得了锁，并且持有锁的线程正在运行，那么可以认为下次的自旋很有可能再次成功，这个自旋将允许等待更长时间
- 相反的，如果对于某个锁自旋很少成功，那么以后获取这个锁将减少自旋甚至省略自旋，从而避免浪费资源。

小结：自适应自旋锁解决的是**锁竞争时间不确定**的问题。 它假定不同线程持有同一个锁对象的时间相当，竞争趋于稳定，从而可以根据上一次自旋的时间与结果来调整下一次的自旋时间

缺点： 没能彻底解决该问题

# 轻量级锁

如果锁竞争激烈，我们需要重量级锁，来让竞争失败的锁阻塞；如果没有实际的竞争情况，那么就需要轻量级锁。

使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record
- 如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；
- 否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争，接下来膨胀为重量级锁。

简单说，轻量锁瞄准的是**没有锁竞争的情况，如果有竞争但是不激烈**，那么就用自旋锁优化，如果自旋失败，就膨胀为重量级锁。

缺点：如果锁竞争激烈，轻量级锁就会膨胀成重量级锁，那么之前轻量级的尝试就白做了

# 偏向锁

再换个场景，在 **没有实际竞争且自始至终使用锁的进程只有一个** 的情况下，轻量级锁都是浪费的。轻量级锁每次申请、释放锁都至少需要一次 CAS，而偏向锁只有初始化时需要一次CAS。

“偏向”的意思是：偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁）

因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空）
- 如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁
- 否则，说明有其他线程竞争，膨胀为轻量级锁。

缺点： 条件太过理想，如果有其它线程申请锁，那么偏向锁就会膨胀成轻量级锁

# 小结

偏向锁、轻量级锁、重量级锁适用于不同的并发场景：
- 偏向锁： 无实际竞争，且将来只有第一个申请锁的线程会使用锁
- 轻量级锁： 无实际竞争，多个线程交替使用锁；允许短时间的锁竞争
- 重量级锁：有实际竞争，且锁竞争时间长

