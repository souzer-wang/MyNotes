[本文原址](https://www.cnblogs.com/dolphin0520/p/3920373.html)
## 一、内存模型相关概念

### CPU 的高速缓存
首先搞清楚一个问题： **为什么 CPU 需要高速缓存？**

> - 计算机中每条指令都是在 CPU 中执行的，执行时需要数据的读取和写入。
> - 临时数据是存放在主存（物理内存）上的
> - 这样的结果是 **CPU执行指令很快，但对内存读写数据就慢得多**
> 所以如果一直这样，整体指令的执行速度就很慢

那么，加入高速缓存后：
- 会将运算需要的数据从主存复制一份到 CPU 的高速缓存中
- CPU 进行计算时可以直接在高速缓存中修改数据
- 运算结束后，再将高速缓存中的数据刷新到主存中

用代码举例：
```java
i = i + 1
```
**线程执行的步骤：**
1. 从主存中读取 i 的值，复制一份到高速缓存中
2. CPU 执行指令对 i 加一，再写入高速缓存
3. 将高速缓存中 i 的最新值刷新到主存

---

### 缓存不一致问题

> 上面这个例子对于单线程是没有问题的，但是如果是多线程的情况就不一定了，比如由两个线程执行这个操作，因为各自读取到了自己所在的CPU高速缓存中，那么最后的计算结果就不是 2， 而是 1.

这就是**缓存不一致问题**，一个变量在多个CPU都存在缓存，那么就有可能不一致。

</br>

从**硬件层面**有两个方法可以解决这个问题：
1. 通过在总线加 LOCK （锁） 的方式
2. 通过缓存一致性协议

#### LOCK 方法
> LOCK 方式的实现：比如某个线程在执行 i = i + 1，那么执行代码的过程中会对总线上锁，那么只有在这段代码执行结束后，其它 CPU 才能从变量 i 所在的内存读取变量。这就解决了缓存不一致问题。
> 这种方法的问题在于：锁住总线期间，其它CPU无法访问内存，效率低下。

#### 缓存一致性协议
由于效率问题，引入了**缓存一致性协议**，比较有名的有 Intel 的 MESI 协议：
> - 当 CPU 写数据时，如果发现该数据是共享数据，即在其它 CPU 也有该变量的副本
> - 就会发出信号通知其它 CPU 该变量的缓存行置为无效
> - 这样的其它 CPU 需要该变量是，发现自己缓存该变量的缓存行无效，就会从内存重新读取

## 二、并发编程的三个概念

并发编程中我们常常遇到三个问题：**原子性、可见性、有序性**

### 原子性

**一个或多个操作，要么全部执行，要么都不执行，不被任何因素打断**
> 举例：假设对一个变量的赋值分为**多个阶段**，那么假如这个赋值不具备原子性，那么可能在完成**一部分的赋值操作**的时候，这个值就**被另一个线程读取**了，这时候读取到的就是错误的值。

### 可见性

当**多个线程访问了同一个变量**的时候，一个线程**修改**了这个变量的值，其它线程马上能看到修改后的值。

举例：
```java
//线程一执行的代码
int i = 0;
i = 10

//线程二执行的代码
j = i
```

假设执行线程一的是 CPU 1，执行线程二的是 CPU 2。

那么当线程一执行到 i = 10这句时，会把 i 的值加载到 CPU1 的高速缓存中，然后赋值为10，那么 CPU1的高速缓存中的值就变成了 10，但是，**如果此时没有写到主存中**

此时如果线程二执行 j = i，它会去读主存中 i 的值，这时候 i 的值还是 0.

### 有序性

顾名思义，所谓有序性，就是**程序执行的顺序按照代码先后的顺序**

> 为什么会出现程序执行顺序和代码顺序不一样？
> 
> 因为有 **指令重排**，具体指，处理器为了提高程序运行的效率，会对输入的代码进行优化。
> 这样优化的结果是：
> - 不保证程序执行的顺序和代码顺序一致
> - 但保证程序最终执行结果和按代码顺序执行的一样

指令重排不会影响单线程的运行结果，但是多线程就不一定了。

举例，先看代码：
```java
//线程一：
context = loadContext(); //语句一
inited = true; //语句二

//线程二
while (!inited) {
    sleep();
}
doSomethingwithconfig(context);
```

先看这里，假如出现**指令重排**，线程一先执行语句二，再执行语句一。

> 问题出在哪儿？
> 
> 在语句二被执行后，线程二会认为初始化已经完成，那么就会跳出 while 循环，执行后面的操作
> 但这个时候如果语句一还没有执行，context就没有初始化，那么程序就会出错。

## Java 内存模型

### 相似点

java内存模型中有很多内容和之前提过的很像，比如：
- 规定所有变量都必须存储在**主存**中，这一点就像前面说的**物理内存**
- 每个线程都有自己的**工作内存**，这个类似前面的**高速缓存**
- 线程对变量的所有操作必须在自己的工作内存中进行，不能直接对主存操作
- 每个线程不能访问其它线程的工作内存

### 原子性

在 Java 中，对**基本数据**类型的变量的**读取和赋值**操作都是原子性的

举个例子，看下面的代码：
```java
x = 10;  //语句一
y = x;  //语句二
x++;  //语句三
x = x + 1;  //语句四
```

这四个语句中，只有第一个是原子性的，直接将 10 赋值给 i

语句二是两步：
1. 读取 x 的值
2. 把这个值写入到工作内存，即 y 等于这个值

语句三和四一样，两步：
1. 读取 x 的值
2. x 等于 这个值+1

由上面的总结，只有最简单的 **读取** 和 **对变量的赋值（如 i = 10）** 是原子操作.

这样的原子性操作范围比较小，如果想要更大的原子性范围，可以通过 synchronized 和 Lock 来实现，它们可以保证 任一时刻只有一个线程执行该代码块。

### 可见性

Java 提供 volatile 关键字来保证可见性。

当一个共享变量被 volatile 修饰时，它会**保证修改后的值马上更新到主存中**，其它线程需要这个值的时候就能从主存读取到最新的值。

如果共享变量没有被 volatile 修饰，那就不能保证可见性了。

另外，synchronized 和 Lock 也能保证可见性，因为在释放锁之后，会把对变量的修改刷新到主存中。

### 有序性

Java 的指令重排不会影响到单线程，但会影响多线程。

而 synchronized 和 Lock 保证了每个时刻都是单线程执行，从而保证了有序性。

而 volatile 可以保证一定的有序性（具体原理见后面）

另外，java 还有一些自带的规则，满足这些规则的程序间必然有序，统称为**happens-before**:
- 🟠**单线程规则**：一个线程内，代码按照书写顺序执行 
- 🟢**锁定原则**：一个 unlock 操作早于后面对同一个锁的 lock 操作
- 🟠**volatile变量规则**：对一个变量的写操作 先于 后面对同一个变量的读操作 
- 🟢**传递操作**：A先于B B先于C 那么A必然先于C
- 🟢**线程启动规则**：

![线程启动](https://img-blog.csdnimg.cn/20200905195701208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjI5NjY5,size_16,color_FFFFFF,t_70#pic_center)

图中，threadB.start() 以及所有早于它的语句，对于线程B都是可见的
- 🟢**线程join**：
![线程join](https://img-blog.csdnimg.cn/20200905195843767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjI5NjY5,size_16,color_FFFFFF,t_70#pic_center)

图中join指令之后的语句可以看到线程b中的所有语句

- 🟢**线程中断规则**：中断操作 先于 被中断的线程对中断的检测操作
- 🟢**线程终结规则**：线程中所有操作都早于线程的终止检测
- 🟢**对象终结规则**：对象构造方法的最后一行指令 先于 finalize() 方法的第一行指令

## volatile 关键字

### 两层语义

当一个共享变量被 volatile 关键字修饰之后，就具备了两个关键属性：
1. 保证了可见性
> 即：一个线程修改了变量的值之后，新值对于其它变量立马可见
2. 禁止进行指令重排

举个栗子：
```java
//线程一
boolean stop = false;
while (!stop) {
    soSomething();
}

//线程二
stop = true;
```

这个栗子是中断线程常用的方法，但也有可能中断失败。

如果线程二在更改了 stop 变量后没有将新值写入主存，转而去做其他事情了，那么线程一就会一直地循环下去。

but，引入了volatile关键字以后就可以解决这个问题：
- volatile 会把新修改的值强行写入主存
- 当线程二修改了变量值以后，会导致线程一中之前缓存的变量值无效
- 线程一发现缓存stop变量的缓存行无效，就会去主存读取新的 stop 变量的值


### 能否保证原子性

并不能，如上面提到的，如果线程一对变量值进行了修改，然后其它线程需要操作该变量就要是去主存读取新值。

但，如果线程一仅仅读取了变量值，在它还没有修改的时候其它线程读取了变量，那么这两个线程对于变量的操作就不会叠加。 如果本来各自加一，总的应该加二的，实际上可能最后还是加一。

### 能否保证有序性

如前面提到的，volatile 能一定程度上保证有序性
举栗：
```java
//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
```

由于 flag 是 volatile 变量：
1. 指令重排的时候，语句3不会放到 语句1，2前面，也不会放到4，5后面
2. 执行到语句3的时候，语句1，2肯定已经执行完，且语句1，2的结果对3，4，5可见

### volatile 的原理和实现机制

根据汇编代码的比较可以发现，当引入volatile关键字后，会多出一个lock前缀指令

lock前缀指令相当于一个内存屏障，它的作用包含：
1. 指令重排时，屏障后的指令不会排到屏障前，反之亦然；执行到屏障这句时，前面的操作已经全部完成
2. 强制将对缓存的修改写入主存
3. 如果是写操作，将其它CPU对应缓存行置为无效

## volatile 的应用

volatile 相对于 synchronized 关键字，
- 优势在于：synchronized 防止多线程同时执行一段代码，所以程序的执行效率会受影响，因而某些情况下 volatile 性能要优于 synchronized
- 劣势在于：volatile 无法保证操作的原子性

使用 volatile 有**两个前提**：
1. 对变量的写操作不依赖于当前值
2. 该变量没有包含在其他变量的不变式中

可以理解为这两条保证操作的原子性

**具体使用的场景，举两个栗子：**
1. 状态标记量
```java
volatile boolean flag = false;

while (!flag) {
    doSomething();
}

public void setFalg() {
    flag = true;
}
```

2. double check
```java
class Singleton{
    private volatile static Singleton istance = null;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if(instance == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

关于 double check 可以参考设计模式部分