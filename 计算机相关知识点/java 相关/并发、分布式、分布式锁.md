# 什么是并发

**并发** 就是 

> **多个执行器**
**同时执行**一个大任务
从而 **缩短执行时间，提高执行效率**


对一个 共享数据 本应独占的读取、检查、修改过程   如果发生了并发

这就叫 `数据竞争`。

这个读取、检查、修改的过程就被称为`临界区`

`临界区`指的就是一个存在`数据竞争`的代码片段。

> 所以**数据竞争** 出现的根本原因是 
> 本来一个数据应该由一个执行器 完整地 完成 读取、检查、修改 的操作
> 如果出现了并发，那么对于某个 执行器 而言， 它执行**修改**这一步时的数据 可能不是 它**读取**时的数据了

---
# 什么是分布式


> 通过多台计算机完成同一任务的方式就可以被称为  **分布式**，
这样的一组计算机的集合就被称为  **集群**。

以仓库发货为例，那么多个仓库进行发货的话，每个仓库就可以看作 一台计算机（一个进程），仓库中的每个人就是进程中的一个线程。

这个时候 总发货清单 就是变成了 一个 `分布式锁` ， 因为它每次只能由一个人（一个线程）编辑，所以是一个`互斥锁`，因为它可以被多个计算机（进程）使用，所以是分布式锁。

补充分布式锁的概念：

> 为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，需要一种跨机器的互斥机制来控制共享资源的访问，这就是分布式锁

## 分布式的CAP理论

任何一个分布式系统都无法同时满足：

**Consistency**  一致性
**Availability** 可用性
**Partition tolerance** 分区容错性

最多只能同时满足两项。而在互联网领域的绝大多数场景中，都是**牺牲强一致性来换取系统的高可用性**，系统往往只保证**最终一致性**


## 概念梳理

- **并发**： 通过多个执行器同时执行一个大任务来缩短执行时间、提高执行效率的方法。

- **数据竞争**： 对一个共享数据本应独占的读取、检查、修改过程发生了并发的情况。


- **临界区**： 存在`数据竞争`的代码片段

- **互斥锁**： （也可以简称为“锁”），同一时间只能由一个执行器获取的实体，用于实现对临界区的互斥（只有一个）访问。

- **分布式**： 通过多台计算机（进程）完成同一任务的方式。

- **集群**： 一组完成同一任务的机器

- **分布式锁**： 在不同机器/进程上提供互斥能力的锁。

- **数据不一致**： 一系列操作不具备原子性，一部分执行充成功另一部分没有，导致不同的数据存在矛盾。比如，订单显示发货，但实际上没有。

- **兜底任务**： 处理`数据不一致`状态的任务

- **最终一致性**： 通过`兜底任务`或其他方式保证`数据不一致`的情况最终会消失。


# 分布式锁

为什么需要分布式锁？

> 在高并发、多线程的情况下，我们需要给对共享资源的操作加一把锁，保证对资源的互斥访问。
> 
> 在Java中， JDK已经为我们提供了这样的锁，就是ReentranLcok或者 synchronized。
> 
> 但在分布式系统中，多线程和多进程分布在不同的机器中，需要自己去实现分布式锁。
>
>**分布式锁的目的** 就是 保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行

 ## 分布式锁需要具备哪些条件
 
 1. 获取锁和释放锁的性能要好（**高性能、高可用**）
 2. **排他性**： 在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。
 3. **具备锁失效机制**： 网络中出现 中断或宕机 无法释放锁的时候，锁必须被清除，不然会发生死锁
 4. **具备阻塞锁&非阻塞锁特性**：当没有获取到锁的时候，非阻塞锁不继续等待（阻塞锁在这个时候会继续等待），直接返回获取锁失败
 5.  **具备可重入性**： 比如一个线程执行了一个带锁的方法（要获取一次锁），这个方法中又执行了另一个需要相同锁的方法（本来也要获取锁），那么就无需再获取一次，可以直接执行这个方法

## 分布式锁实现的方式

1. 基于数据库实现分布式锁
2. 居于缓存（Redis等）实现分布式锁
3. 基于 Zookeeper 实现分布式锁

### 基于数据库实现

#### 基于MySql锁表：（数据库众多方式中的一种）

> 主要原理是 **在方法名上创建唯一索引**
> 
> 想要获得锁，就用该方法向数据库的表中插入一条记录
> 
> 想释放锁，就删除这条记录

这种做法的问题在于：

1. 因为基于数据库，数据库的可用性和性能将影响到分布式锁的可用性和性能。数据库是一点单点，如果数据库挂掉，那么整个业务系统就不可用了。

解决方法：搞个备用数据库，主数据库挂掉就切换。

2. 不可重入，同一线程在释放锁之前，行数据一直存在，无法再次插入

解决方法：再数据库中再加一条，记录获取到锁的机器和线程信息，下次再有获取请求，判断是否为同一线程，如果是，允许再次获取（即实现可重入）

3. 没有锁失效机制（可能的结果：插入数据后服务器宕机，对应数据没被删除，服务恢复后就一直获取不到锁）

解决方法：在表中新增一列，记录失效时间，并定时清除失效数据

4. 不具备阻塞锁特性（只有非阻塞锁），获取不到锁会直接返回获取锁失败

解决方法：优化获取逻辑，循环多次获取（while循环，直到insert成功再返回成功）

#### 基于数据库的排他锁
#### 乐观锁

### 基于数据库实现的优缺点分析

优点：
- 直接借助数据库，容易理解

缺点：
- 问题会比较多，处理问题会使方案变得更加复杂
- 操作数据库需要一定的开销，影响性能
- 使用数据库的行级锁并不一定靠谱，特别是锁表不大的时候

---
### 基于缓存实现分布式锁

基于缓存相较于基于数据库来说，性能方面更好一点，还可以解决单点问题。

> 补充：什么是分布式系统中的**单点问题**
>
> 通常分布式采用主从模式，也就是一个主机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当主节点出现故障的时候，整个系统就会瘫痪。 
> 这就是单点故障

题外话结束，目前有很多成熟的缓存产品，包括： Redis，memcached等

基于Redis实现的分布式锁也分几种：

#### 基于setnx、expire来实现（针对单机Redis实例）

先解释以下使用到的命令：

1. setnx：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。
2. expire：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。
3. delete：删除key

实现思想：

1. 在获取锁的时候，使用setnx了加锁，并使用expire为锁加上一个超时时间，如果超时自动释放锁，锁的value为一个随机生成的UUID
2. 获取锁的时候设置一个获取的超时时间，若超过这个时间，则放弃获取锁
3. 释放锁的时候，通过UUID来判断是不是该锁，如果是，执行delete进行锁的释放

#### Redlock算法（针对多个Redis实例）

算法内容：
1. 获取当前的时间
2. 尝试从五个独立的Redis客户端获取锁
3. 计算获取所有锁消耗的时间，当且仅当满足下面两个条件，认为获得了锁（如果不满足，即没有获取到锁，释放已锁的Redis）
	1. 获得超过半数节点的锁（>=3）
	2. 获取锁的时间小于锁的有效时间
4. 重新计算有效期时间（原有效时间-获取锁消耗的时间）
5. 删除所有的实例

相较于单节点Redis锁，redlock实现起来条件更为严苛：
1. 必须部署五个节点，才能让redlock的可靠性更强
2. 必须超过半数才能算请求成功，如果有部分节点宕机（假设两个），那么原本超过半数的条件（>=3）就变成了全部（=3），获取锁的难度大大增加。

### 小结

通过缓存实现分布式锁的优点：
- 性能好，实现起来较为方便

缺点是：
- 通过超时时间来控制锁的失效时间 不是很靠谱

---
### 基于Zookeeper实现分布式锁

> Zookeeper 是什么？
> 是一个为分布式应用提供一致性服务的开源组件
> 
> 它的内部是一个分层的文件系统目录树结构，同一目录下只能有唯一文件名

先说一下zookeeper的特点：
- 数据模型：
	- 永久节点： 节点创立后不会因为会话结束而消失
	- 临时节点： 客户端连接结束会立即删除节点
	- 顺序节点： 在节点后加数字后缀并且有序


- 监视器（watcher）
	- 创建节点时，注册该节点的监视器，当节点状态变化，watcher将被触发，Zookeeper会向客户端发送通知（watcher只会被触发一次）


具体实现步骤如下：
1. 创建一个目录 mylock
2. 线程 A 要是想获取锁就在 mylock 目录下**创建临时顺序节点**
3. A 获取 mylock 目录下所有子节点，查找比自己小的兄弟节点：
	1. 如果不存在，说明A线程是当前最小，获得锁
	2. 如果存在，监听比自己小的那个线程
4. 这时假设又来个线程 B 想获取锁，重复 3 操作，
5. （假设此时A获得了锁）当A处理完，删除节点后，B监听到变更时间，再次判断自己是不是最小节点，如果是获得锁，如果不是，继续监听（像3一样）

#### 补充：Zookeeper是如何解决分布式系统的单点故障的

> 解决单点问题的传统方式 是采用一个备用节点
>
>1. 备用节点定期向主节点发送ping包
>2. 主节点收到后向备用节点恢复ACK
>3. 备用节点收到回复后就认为主节点还活着


但这种方式会收到网络问题的影响：
> 1. 如果主节点没有挂，但是因为网络的问题，备用节点没收到回复
> 2. 那么它会认为主节点挂掉了，备用节点会启动
> 3. 这时候系统中就有了两个主节点，即双Master，那么有的节点会汇报给主节点，有的会汇报给备用节点，那就乱了

**Zookeeper的解决方法**

解决原理和上面讲到的很像：
1. 假设有两个主节点 A 和 B，那么它们启动后会分别向Zookeeper注册一个节点，假设分别是A:master-00001， B:master-00002
2. 注册完成后会进行选举，编号最小的（此时为A）将在选举中获胜，然后获得锁成为主节点，然后节点B会成为备用节点
3. 如果主节点A挂掉了，它注册的节点会被删掉；然后再次选举，B会成为新的主节点
4. 即便A接下来恢复了，它会再向Zookeeper注册一个节点，假设是master-00003
5. 这是Zookeeper感知到节点变化，再次发起选举，这时主节点 B 再次获胜，A变为备用节点

### 简单小结


　　数据库锁：

-   优点：直接使用数据库，**使用简单**。
    
-   缺点：分布式系统大多数瓶颈都在数据库，使用数据库锁会**增加数据库负担**。
    

　　缓存锁：

-   优点：**性能高**，实现起来较为**方便**，在允许偶发的锁失效情况，不影响系统正常使用，建议采用缓存锁。
    
-   缺点：通过锁**超时机制不**是十分**可靠**，当线程获得锁后，处理时间过长导致锁超时，就失去了锁的作用。
    

　　zookeeper锁：

-   优点：高可用、可重入、阻塞锁特性，可解决失效死锁问题，可靠性高；系统要求高可靠性时，建议采用zookeeper锁。
    
-   缺点：性能比不上缓存锁，因为要频繁的创建节点删除节点。




### 三种方案的比较


-   **从理解的难易程度角度（从低到高）**  
    数据库 > 缓存 > Zookeeper
    
-   **从实现的复杂性角度（从低到高）**  
    Zookeeper >= 缓存 > 数据库
    
-   **从性能角度（从高到低）**  
    缓存 > Zookeeper >= 数据库
    
-   **从可靠性角度（从高到低）**  
    Zookeeper > 缓存 > 数据库
	


