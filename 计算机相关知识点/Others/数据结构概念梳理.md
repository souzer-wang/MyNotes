# 数据结构

数据结构我们可以从两个维度去理解：
- 逻辑结构
- 存储结构

### 逻辑结构

逻辑结构大概统一的可以分成两种：线性结构、非线性结构。

**线性结构：** 是一个有序数据元素的集合。其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。

常用的线性结构有: 栈，队列，链表，线性表。

**非线性结构：** 各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。

常见的非线性结构有 二维数组，树等。

### 存储结构

逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。常见的存储结构有顺序存储、链式存储、索引存储以及散列存储。

例如：数组在内存中的位置是连续的，它就属于顺序存储；链表是主动建立数据间的关联关系的，在内存中却不一定是连续的，它属于链式存储；还有顺序和逻辑上都不存在顺序关系，但是你可以通过一定的方式去放问它的哈希表，数据散列存储

## 二叉树

### 二叉树的遍历

> 重点中的重点，最好同时掌握递归和非递归版本，递归版本很容易书写，但是真正考察基本功的是**非递归版本**。

-   二叉树的中序遍历
    
-   二叉树的前序遍历
    
-   二叉树的后序遍历

> 根据前序遍历和中序遍历的特点重建二叉树，逆向思维，很有意思的题目

-   重建二叉树
    
-   求二叉树的遍历

### 二叉树的对称性

-   对称的二叉树
    
-   二叉树的镜像

### 二叉搜索树

> 二叉搜索树是特殊的二叉树，考察二叉搜索树的题目一般都是考察二叉搜索树的特性，所以掌握好它的特性很重要。

-   二叉搜索树的第k个节点
    
-   二叉搜索树的后序遍历

### 二叉树的深度

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

平衡二叉树：左右子树深度之差大于1

-   二叉树的最大深度
    
-   二叉树的最小深度
    
-   平衡二叉树

## 链表

> 用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。

-   需要遍历才能查询到元素，查询慢。
    
-   插入元素只需断开连接重新赋值，插入快。

### 基本应用

> 主要是对链表基本概念和特性的应用，如果基础概念掌握牢靠，此类问题即可迎刃而解

-   从尾到头打印链表
    
-   删除链表中的节点
    
-   反转链表
    
-   复杂链表的复制

### 环类题目

> 环类题目即从判断一个单链表是否存在循环而扩展衍生的问题

-   环形链表
    
-   链表环的入口节点
    
-   约瑟夫环

### 双指针

> 双指针的思想在链表和数组中的题目都经常会用到，主要是利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。

-   两个指针从不同位置出发：一个从始端开始，另一个从末端开始；
    
-   两个指针以不同速度移动：一个指针快一些，另一个指针慢一些。
    

对于单链表，因为我们只能在一个方向上遍历链表，所以第一种情景可能无法工作。然而，第二种情景，也被称为慢指针和快指针技巧，是非常有用的。

-   两个链表的公共节点
    
-   链表倒数第k个节点
    
-   相交链表

### 双向链表

双链还有一个引用字段，称为 `prev`字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。

-   扁平化多级双向链表

## 数组

### 双指针

> 上面链表中提到的一类题目，主要是利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。注意这种技巧经常在排序数组中使用。

-   调整数组顺序使奇数位于偶数前面
    
-   和为S的两个数字
    
-   和为S的连续正整数序列

### N数之和问题

> 非常常见的问题，基本上都是一个套路，主要考虑如何比暴利法降低时间复杂度，而且也会用到上面的双指针技巧

-   两数之和
    
-   三数之和
    
-   四数之和

### 二维数组

> 建立一定的抽象建模能力，将实际中的很多问题进行抽象

-   构建乘积数组
    
-   顺时针打印矩阵

### 数据统计

> 数组少不了的就是统计和计算，此类问题考察如何用更高效的方法对数组进行统计计算。

-   数组中出现次数超过数组长度一半的数字
    
-   连续子数组的最大和
    
-   扑克牌顺子
    
-   第一个只出现一次的字符

## 栈和队列

-   队列和栈的互相实现
    
-   包含min函数的栈
    
-   栈的压入弹出序列
    
-   滑动窗口最大值
    
-   接雨水

## 哈希表

> 如何设计哈希函数以及如何避免冲突就是哈希表的常见问题。好的哈希函数的选择有两条标准：

-   1.简单并且能够快速计算
    
-   2.能够在址空间中获取键的均匀人分布
    

例如下面的题目：

-   常数时间插入、删除和获取随机元素
    

> 当用到哈希表时我们通常是要开辟一个额外空间来记录一些计算过的值，同时我们又要在下一次计算的过程中快速检索到它们，例如上面提到的两数之和、三数之和等都利用了这种思想。

-   两数之和
    
-   三数之和
    
-   字符流中第一个不重复的字符
    
-   宝石与石头

## 堆

堆的底层实际上是一棵完全二叉树，可以用数组实现

-   每个的节点元素值不小于其子节点 - 最大堆
    
-   每个的节点元素值不大于其子节点 - 最小堆
    

> 堆在处理某些特殊场景时可以大大降低代码的时间复杂度，例如在庞大的数据中找到最大的几个数或者最小的几个数，可以借助堆来完成这个过程。

-   堆的基本操作
    
-   数据流中的中位数
    
-   最小的k个数

# 算法

## 排序

-   快速排序
    

> 选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。

-   归并排序
    

> 将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。

-   选择排序
    

> 每次排序取一个最大或最小的数字放到前面的有序序列中。

-   插入排序
    

> 将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。

-   冒泡排序
    

> 循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。

-   堆排序
    

> 创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。

## 二分查找

二分查找维护查找空间的左、右和中间指示符，并比较查找目标或将查找条件应用于集合的中间值；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查以空的一半结束，则无法满足条件，并且无法找到目标。

-   二维数组查找
    
-   旋转数组的最小数字
    
-   在排序数组中查找数字
    
-   x 的平方根
    
-   猜数字大小

## 递归

你可能想知道如何实现调用自身的函数。诀窍在于，每当递归函数调用自身时，它都会将给定的问题拆解为子问题。递归调用继续进行，直到到子问题无需进一步递归就可以解决的地步。

为了确保递归函数不会导致无限循环，它应具有以下属性：

-   一个简单的基本案例 —— 能够不使用递归来产生答案的终止方案。
    
-   一组规则，也称作递推关系，可将所有其他情况拆分到基本案例。

### 重复计算

一些问题使用递归考虑，思路是非常清晰的，但是却不推荐使用递归，例如下面的几个问题：

-   斐波拉契数列
    
-   跳台阶
    
-   矩形覆盖

你可以使用 `记忆化`的方法来避免重复计算，即开辟一个额外空间来存储已经计算过的值，但是这样又会浪费一定的内存空间。因此上面的问题一般会使用动态规划求解。

> 所以，在使用递归之前，一定要判断代码是否含有重复计算，如果有的话，不推荐使用递归。

递归是一种思想，而非一个类型，很多经典算法都是以递归为基础，因此这里就不再给出更多问题。

## 广度优先搜索

-   从上到下打印二叉树
    
-   单词接龙
    
-   员工的重要性
    
-   岛屿数量

## 深度优先搜索

-   二叉树的中序遍历
    
-   二叉树的最大深度
    
-   路径总和
    
-   课程表
    
-   岛屿数量

## 回溯算法

-   二叉树中和为某一值的路径
    
-   字符串的排列
    
-   和为sum的n个数
    
-   矩阵中的路径
    
-   机器人的运动范围
    
-   N皇后问题

## 动态规划

### 路径问题

-   最小路径和
    
-   不同路径
    
-   不同路径 II
    
-   形成字符串的最短路径

### 买卖股票类问题

-   买卖股票的最佳时机
    
-   买卖股票的最佳时机 III
    
-   打家劫舍
    
-   打家劫舍 II

### 子序列问题

-   不同的子序列
    
-   乘积最大子序列
    
-   最长上升子序列
    
-   最长回文子序列


## 贪心算法

### 买卖股票类问题

-   买卖股票的最佳时机 II
    
-   买卖股票的最佳时机含手续费

### 货币选择问题

-   零钱兑换
    
-   零钱兑换 II

## 贪心算法、动态规划、回溯的区别

贪心算法与动态规划的不同在于它对每个子问题的解决方案都作出选择，不能回退，动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能，而回溯算法就是大量的重复计算来获得最优解。

