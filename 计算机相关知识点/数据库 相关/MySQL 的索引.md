## 磁盘 I/O 与 预读

磁盘读取数据花费的时间可以发为：
1. 寻道时间：磁臂移动到指定磁盘所需要的时间，主流磁盘在 5ms 以下
2. 旋转延迟：即磁盘转速，举例：一个磁盘 7200 转，表示每分钟磁盘转 7200 次，即 120次每秒，即 一次4.17ms
3. 传输时间：从磁盘读/写数据的时间，一般为零点几毫秒，相较于前两者可以忽略

以上时间加起来，约为9ms，对于数据库动辄百万或千万的数据，每次 9ms 的时间，不可想象。

因为磁盘 I/O 的成本巨大，计算机为了优化，在一次 I/O 的时候，不光会把当前磁盘的数据读取到内存中，还会把相邻的数据读取到内存缓冲区中（空间局部性原理）。而每页数据的大小与操作系统有关，一般为 4K 或 8K。

## 索引的数据结构

下图是B+树的数据结构

![B+树结构图](https://img-blog.csdn.net/20160620140312586)

### B+ 树的性质

根据上图，分析一下 B+树的性质

- 图中浅蓝色的模块，称为磁盘块，每个磁盘块中包含几个数据项（深蓝色）和指针（黄色）

- 图中磁盘块 1 包含数据 17 和 35，还有指针 P1，P2，P3，其中 P1 指向小于 17 的磁盘块 2，以此类推

- 真实的数据只存在叶子节点上，而非叶子节点中不存储数据，比如图里面的指引搜索方向的数据项（如17，35，8，12等），并不真实存在于数据表中

### B+ 树的查找过程

还是以上图为例，假如查找 29：
1. 首先由将磁盘一加载到内存，即一次 I/O
2. 然后利用二分查找确定 P2 指针，然后加载磁盘三，即第二次 I/O（内存计算时间相较于 I/O 非常短，可以忽略）
3. 然后同样的方法，找到并加载磁盘八，即第三次 I/O，内存计算查找到 29

整个过程一共进行了三次 I/O，而实际场景中，三层的 B+ 树可以存储上百万的数据，换句话说，上百万的数据查起来只要三次 I/O，性能是非常优越的，这也就是 B+ 树的优势所在。

### B+ 树的性质

1. I/O 的次数取决于 B+ 树的高度 H，设当前的数据量为 N，每个磁盘块的数据项有 M 个，则有 H = log(M + 1) N，当数据量 N 一定的情况下，M 越大，H 越小。 即磁盘内数据项越多，树的高度越小。

> 实际上磁盘块的大小是固定的，所以数据项所占据的空间越小，数据项的数量就越大。这就是为什么每个数据项的索引字段要尽可能的小，比如 int 占 4 个字节，比 bigint 的 8 个字节小一半。
> 所以 B+ 树要把真实数据放到叶子节点而不是内层节点中。因为如果放到内层节点里，每个磁盘块内的数据项就会减少，即上式里的 M 减小，则H会增大，树的高度增加。当数据项为 1 时，就退化成了线性表

2. B+ 树的数据项是复合数据结构，比如对于 （name，age，gender），B+ 树按照从左到右的顺序建立搜索树。而查找的时候也是一层层去查找，如果字段有缺失，比如缺失了name，那么就无法继续查找，如果是后面的字段缺失了，比如缺失了gender，那么就返回所有符合name和age值的结果。这就是 **最左匹配原则**

## 索引的类型

MySQL 中索引分为： （待补充）
- 聚簇索引
	- 按照数据存放的物理位置为顺序
	- 可提高多行检索的速度
- 非聚簇索引
	- 对单行的检索速度很快

还可以进行细分，分成四类：
1. 普通索引：最基本的索引，略
2. 唯一索引(UNIQUE)：与普通索引类似，不同的是唯一索引的列值必须唯一，但允许为空值
3. 全文索引(FULLTEXT)：仅可以适用于MyISAM引擎的数据表，作用于 CHAR、VARCHAR、TEXT数据类型的列
4. 组合索引：将几个列作为一条索引进行索引，适用最左匹配原则

建立索引的一些原则：
1. 最左匹配原则，MySQL 会一直向右匹配，直到遇到 范围查询就停止匹配，举例：

> a = 1 and b = 2 and  c > 3 and d = 4
> 如果是按照 a,b,c,d 的顺序来建立索引，那么这里 d 是用不到索引的
> 但如果是按照 a,b,d,c 建立索引，则是可以的

2. 等于 = 和 in 可以乱序，比如 a = 1 and b = 2 and c = 3，这里 a,b,c 的顺序就可以打乱

3. 尽量选择区分度高的列作为索引（重复率低的）

4. 索引列不能参与计算，举例：

> FROM_UNIXTIME(create_time) = '2016-06-06' 不合适，可以写成
> create_time = UNIX_TIMESTAMP('2016-06-06')

5. 如果有需要，尽可能在原来的索引上改，尽量不要新建索引

6. 单个多列组合索引 和 多个单列索引的检索查询效果不同

以下面的 SQL 语句为例
```sql
SELECT 
count(*) AS count 
FROM trade_bASe AS a
WHERE 
a.trade_status = 7 
AND a.create_time BETWEEN '2015-09-01' AND '2016-01-14' 
AND a.booking_source = '2'
```

这里需要建立的索引应该是 trade_status, booking_source, create_time 的联合索引，前两个顺序可以颠倒，这就是利用了 **最左匹配原则**


## 索引的优化

1. 何时使用聚簇索引或者非聚簇索引

|使用动作描述|使用聚簇索引|使用非聚簇索引|
|:-:|:-:|:-:|
|列经常被分组排序|✔|✔|
|返回某范围内的数据|✔|✖|
|一个或极少不同的值|✖|✖|
|小数目不同的值|✔|✖|
|大数目不同的值|✖|✔|
|频繁更新的列|✖|✔|
|外键列|✔|✔|
|主键列|✔|✔|
|频繁修改索引列|✖|✔|

2. 索引不会包含有 null 值的列，只要列中包含有 NULL 值，都将不会被包含在索引中
3. 使用短索引
4. 索引列排序
5. 不要在索引列进行计算