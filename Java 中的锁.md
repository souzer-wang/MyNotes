# 自适应自旋锁

自适应的意思是 **自选时间不再固定**，而是由前一次在同一个锁上的自旋时间及锁的拥有者来决定：
- 如果在同一个锁对象上，之前通过自旋方式获得了锁，并且持有锁的线程正在运行，那么可以认为下次的自旋很有可能再次成功，这个自旋将允许等待更长时间
- 相反的，如果对于某个锁自旋很少成功，那么以后获取这个锁将减少自旋甚至省略自旋，从而避免浪费资源。

小结：自适应自旋锁解决的是**锁竞争时间不确定**的问题。 它假定不同线程持有同一个锁对象的时间相当，竞争趋于稳定，从而可以根据上一次自旋的时间与结果来调整下一次的自旋时间

缺点： 没能彻底解决该问题

# 轻量级锁

如果锁竞争激烈，我们需要重量级锁，来让竞争失败的锁阻塞；如果没有实际的竞争情况，那么就需要轻量级锁。

使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record
- 如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；
- 否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争，接下来膨胀为重量级锁。

简单说，轻量锁瞄准的是没有锁竞争的情况，如果有竞争但是不激烈，那么就用自旋锁优化，如果自旋失败，就膨胀为重量级锁。

缺点：如果锁竞争激烈，轻量级锁就会膨胀成重量级锁，那么之前轻量级的尝试就白做了

# 偏向锁

再换个场景，在 **没有实际竞争且自始至终使用锁的进程只有一个** 的情况下，轻量级锁都是浪费的。轻量级锁每次申请、释放锁都至少需要一次 CAS，而偏向锁只有初始化时需要一次CAS。

“偏向”的意思是：偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁）

因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空）
- 如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁
- 否则，说明有其他线程竞争，膨胀为轻量级锁。

