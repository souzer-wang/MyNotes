## 一、内存模型相关概念

首先搞清楚一个问题： **为什么 CPU 需要高速缓存？**

> - 计算机中每条指令都是在 CPU 中执行的，执行时需要数据的读取和写入。
> - 临时数据是存放在主存（物理内存）上的
> - 这样的结果是 **CPU执行指令很快，但对内存读写数据就慢得多**
> 所以如果一直这样，整体指令的执行速度就很慢

那么，加入高速缓存后：
- 会将运算需要的数据从主存复制一份到 CPU 的高速缓存中
- CPU 进行计算时可以直接在高速缓存中修改数据
- 运算结束后，再将高速缓存中的数据刷新到主存中

用代码举例：
```java
i = i + 1
```
线程执行的步骤：
1. 从主存中读取 i 的值，复制一份到高速缓存中
2. CPU 执行指令对 i 加一，再写入高速缓存
3. 将高速缓存中 i 的最新值刷新到主存

> 上面这个例子对于单线程是没有问题的，但是如果是多线程的情况就不一定了，比如由两个线程执行这个操作，因为各自读取到了自己所在的CPU高速缓存中，那么最后的计算结果就不是 2， 而是 1.

这就是**缓存不一致问题**，一个变量在多个CPU都存在缓存，那么就有可能不一致。

从**硬件层面**有两个方法可以解决这个问题：
1. 通过在总线加 LOCK （锁） 的方式
2. 通过缓存一致性协议

> LOCK 方式的实现：比如某个线程在执行 i = i + 1，那么执行代码的过程中会对总线上锁，那么只有在这段代码执行结束后，其它 CPU 才能从变量 i 所在的内存读取变量。这就解决了缓存不一致问题。
> 这种方法的问题在于：锁住总线期间，其它CPU无法访问内存，效率低下。

由于效率问题，引入了**缓存一致性协议**，比较有名的有 Intel 的 MESI 协议：
> - 当 CPU 写数据时，如果发现该数据是共享数据，即在其它 CPU 也有该变量的副本
> - 就会发出信号通知其它 CPU 该变量的缓存行置为无效
> - 这样的其它 CPU 需要该变量是，发现自己缓存该变量的缓存行无效，就会从内存重新读取

