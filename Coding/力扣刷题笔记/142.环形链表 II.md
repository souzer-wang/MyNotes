## 题意

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

**说明：** 不允许修改给定的链表。

**进阶：**

你是否可以使用 O(1) 空间解决此题？

---
## 解题

本题还是用快慢指针的方法解决，快指针每次走两步，慢指针每次走一步。
首先我们需要明确一点，就是当慢指针进环后，还没有走完第一圈，快指针就赶上它了。

证明：

	假设慢指针入环时，快指针相对入环口走了 a 步，而后慢指针走了 b 步与快指针相遇，环的长度为 c，那么我们可以得到
	
	a+2b=b+nc  (n 为快指针多走的圈数)
	
	进而得到  a+b=nc
	我们可以看出，以慢指针为参照物，那么快指针实际上是以 1 的速度前进，它必然会追上慢指针，它第一次追上的时候多走的路程一定是一圈，不可能是两圈。
	因为如果是两圈的话，相当于跳过了一次，而刚刚提到快指针的相对步速是 1，是不可能跳过的。
	所以此处 n为1 ，那么有 a+b=c --> b<c
	
	即第一次相遇时，慢指针还没有走完第一圈


以下图为例：

![[Pasted image 20210122213712.png]]

图中 a表示入环前的距离，b+c为环的长度，绿点为两个指针相遇的地方，那么我们可以得到，a+b+n(b+c)=2(a+b)

进而可以得到 a=c+(n-1)(b+c)，这时再从头部出发一个指针，当它走了c+(n-1)(b+c) 步时到达入环口，所以定义一个指针，让他和慢指针同时以 1 的速度移动，这样二者会在入环口相遇。

```python
fast=slow=head
while True:
	if not (fast and fast.next):
		return 
	fast,slow=fast.next.next,slow.next
	if fast==slow:
		break
fast=head
while fast!=slow:
	fast,slow=fast.next,slow.next
return fast
```