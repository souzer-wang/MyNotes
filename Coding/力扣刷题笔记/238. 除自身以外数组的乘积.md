## 题意

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

**eg**

**输入:** `[1,2,3,4]`
**输出:** `[24,12,8,6]`

**提示：** 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明：** 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

**进阶：**
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）


---
## 解题

看到题目我们马上能想到的方法就是先计算一个总乘积，然后对数组进行遍历，每次在输出数组上添加总乘积处理当前数。  但由于说明中要求不能使用出发，所以排除了。

如果选择遍历时将除当前数之外的所有数乘起来，则时间复杂度会达到O($n^2$)，也不满足要求，排除。

### 存储左右乘积

上面这个做法之所以会达到 O($n^2$) 的时间复杂度，是因为在遍历时，对于每个数都要重新计算左右的乘积，其实多了很多不必要操作，我们可以先用两个数组把从左往右和从右往左的乘积存储起来，然后在计算输出数组的时候就可以直接使用了。

1. 前后分别遍历，得到左右乘积
2. 一次循环，每次将左右乘积相乘，加到输出数组

```pyhon
n=len(nums)
left,right=[1]*n,[1]*n
res=[]
for i in range(1,n):
	left[i]=left[i-1]*nums[i-1]
for i in range(n-2,-1,-1):
	right[i]=right[i+1]*nums[i+1]
for i in range(n):
	res.append(left[i]*right[i])
return res
```
时间复杂度为O(n)

### 改进

上面这个方法进行了三次遍历，那么实际上，可以把第二次和第三次合起来。

即先存左边的乘积，然后从右边开始遍历，一边计算右边乘积后再乘左边乘积，一边添加到输出数组。 当然左右顺序反过来也可以。

而且，我们再进行简化，把左乘积数组和输出数组进行合并，这样就满足了进阶的要求。

```python
n=len(nums)
res=[1]*n
for i in range(1,n):
	res[i]=res[i-1]*nums[i-1]
tmp=1
for i in range(n-1,-1,-1):
	res[i]=tmp*res[i]
	tmp*=nums[i]
return res
```

时间复杂度为 O(n)，空间复杂度为O(1)