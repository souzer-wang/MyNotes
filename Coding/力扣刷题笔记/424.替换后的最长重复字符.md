## 题意

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 _k_ 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

**注意：** 字符串长度 和 _k_ 不会超过 $10^4$。

eg.

**输入：** s = "ABAB", k = 2
**输出：** 4
**解释：** 用两个'A'替换为两个'B',反之亦然。

## 解题

先看看官方题解原文：

	我们可以枚举字符串中的每一个位置作为右端点，然后找到其最远的左端点的位置，满足该区间内除了出现次数最多的那一类字符之外，剩余的字符（即非最长重复字符）数量不超过 kk 个。

	这样我们可以想到使用双指针维护这些区间，每次右指针右移，如果区间仍然满足条件，那么左指针不移动，否则左指针至多右移一格，保证区间长度不减小。

	虽然这样的操作会导致部分区间不符合条件，即该区间内非最长重复字符超过了 kk 个。但是这样的区间也同样不可能对答案产生贡献。当我们右指针移动到尽头，左右指针对应的区间的长度必然对应一个长度最大的符合条件的区间。

	实际代码中，由于字符串中仅包含大写字母，我们可以使用一个长度为 2626 的数组维护每一个字符的出现次数。每次区间右移，我们更新右移位置的字符出现的次数，然后尝试用它更新重复字符出现次数的历史最大值，最后我们使用该最大值计算出区间内非最长重复字符的数量，以此判断左指针是否需要右移即可。
	
我觉得官方题解的表达有些问题，看了有点绕，我是看了第二遍才看明白，其实就是个滑动窗口，直白点说，解题思路如下：
1. 用左右指针来维护一个区间（即滑动窗口），保证这个区间内 **非最多元素** 的数量 ≤k
2. 每次移动区间时，先动右边，看看动完后是否还满足上面这个条件
	1. 满足：最大长度+1
	2. 不满足：左指针跟着右移一步，最大长度不变
3. 右指针走到底以后，不管当前的字符串满不满足条件，它的长度就是答案（字符串中存在着一个这个长度的字符串满足题意）。

代码：

```python
left,right,maxl=0,0,0
n=len(s)
helper=[0]*26

while right<n:
	#计算右指针字母在helper数组的序号,然后加一
	tmp=ord(s[right])-ord("A")
	helper[tmp]+=1
	#找出当前最多字符的数量
	maxl=max(maxl,helper[tmp])
	#判断左指针是否移动
	if right-left+1-maxl>k:
		helper[ord(s[left])-ord("A")]-=1
		left+=1
	right+=1
return right-left
```