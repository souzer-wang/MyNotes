## TCP 通过哪些方式来保证数据的可靠性？
**TCP 保证数据可靠性的方式大致可以分为三类：**

-   在数据包层面：校验和
-   在数据包传输层面：序列号、确认应答、超时重传
-   在流量控制层面：拥塞控制

### 校验和
计算方式：在数据传输的过程中，将发送的数据段都当做一个 16 位的整数。将这些整数加起来。并且加上进位，最后取反，得到校验和。
TCP 与 UDP 校验方式相同

### 序列号、确认应答、超时重传
在数据包传输的过程中，每个数据包都有一个序列号，当数据到达接收方时，接收方会发出一个确认应答，表示收到该数据包，并会说明下一次需要接收到的数据包序列号(32 位确认序列号)。如果发送端在一段时间内(2RTT 没有收到确认应答，则说明可能是发送的数据包丢失或者确认应答包丢失，此时发送端会进行数据包重传。

但发送端并不是一定要等到接收到上一个数据包的确认应答再发送下一个数据包，TCP 会利用窗口控制来提高传输速度，在一个发送窗口大小内，不用一定要等到应答才能发送下一段数据，发送窗口大小就是无需等待确认而可以继续发送数据的最大值。而发送窗口的大小是由接收端的接受窗口的剩余大小和拥塞窗口来决定的。(TCP 会话的双方都各自维护一个发送窗口和一个接收窗口)

### 拥塞控制
发送端维持一个叫做拥塞窗口 cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送端让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

TCP 的拥塞控制主要是采用慢启动以及增性加，乘性减的机制，TCP一开始将拥塞窗口设置的很小，在逐渐经过一段时间的指数增长后超过门限，进入增性加阶段，此时窗口大小的增长是线性的，比之前的指数增长要慢很多，而当发生网络拥塞时，拥塞窗口大小直接减半（乘性减）。

## 什么是粘包、拆包，如何解决？

假设客户端向服务器发送了两个数据包，packet1 和 packet2，那么服务器的接收情况可能有以下三种：

1. 正常收到两个数据包

![](https://images2018.cnblogs.com/blog/1422100/201808/1422100-20180822164943488-1549063928.png)

2. 只收到一个数据包，两个包合到了一起

![](https://images2018.cnblogs.com/blog/1422100/201808/1422100-20180822164950622-1403347423.png)

3. 收到了两个包，但一个不完整，一个多出了一块

![](https://images2018.cnblogs.com/blog/1422100/201808/1422100-20180822164958646-1790874821.png)

![](https://images2018.cnblogs.com/blog/1422100/201808/1422100-20180822165003871-693771235.png)

### 为什么会粘包、拆包？

可能原因：
- 应用程序写入的数据大于套接字缓冲区大小，会拆包
- 应用程序写入的数据小于套接字缓冲区大小，会粘包
- 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包
- 接受方法不及时读取数据，就会粘包

### 解决方法

- 给每个包添加包首部，在首部中包含数据包的长度
- 将每个数据包封装为固定长度
- 在数据包间设置边界，如添加特殊符号

## TCP 和 UDP

### 两者的区别

- 一个有连接，一个无连接
- TCP要求的系统资源较多，而UDP要求的较少
- UDP的程序结构较简单
- TCP是流模式，UDP是数据报模式
- TCP保证可靠性，UDP可能丢包
- TCP保证数据顺序，UDP不保证

### UDP的应用场景

- 面向数据报方式
- 网络数据大多为短消息
- 拥有大量client
- 对数据安全性无特殊要求
- 对响应速度要求高

### tcp,udp如何处理过大数据包
- udp如果要发送超出了限定值大小的数据包，会报错
- tcp是数据流协议，没有包大小限制，会分段发送



## 三次握手的目的是什么：

TCP 三次握手的主要目的是防止失效的连接请求报文被服务端接受

如果只有两次握手，假设当客户端发送第一次连接请求由于网络拥塞的原因，迟迟未到服务端，客户端没接收到确认报文，认为服务端没有收到，于是重新发送请求报文并与服务端建立连接，等这次连接断开了，之前滞留的那个请求报文又到达了服务端，就会让服务端与客户端再次连接成功，这时服务端就会一直等待客户端发送请求，造成了资源的浪费。

两次握手只能保证单向链路是可以通信的，理论上来说，要保证双向链路可以通信需要四次握手，但实际上服务端给客户端的 SYN 和 ACK 数据包可以合为一次握手，所以实际上只需要三次握手即可。

### 加问：那挥手为什么需要四次呢？三次不行吗？
答：挥手阶段中服务端的 ACK 和 FIN 数据包不能合为一次。因为挥手阶段的流程为客户端发送FIN数据包表示自己发完了，服务端立即回复 ACK 数据包表示自己知道了，此时客户端到服务端的连接已经释放了，客户端不会再发送数据了，但服务端还可以继续向客户端发送数据，等到服务端也完成了数据发送，才会发送 FIN，这时客户端回复 ACK，就可以结束通信了。

### 加问：TCP 在四次挥手的过程中为什么客户端最后还要等待 2MSL(Maximum Segment Lifetime)？
答：因为客户端要保证他的 ACK 包顺利到达服务端，如果客户端的ACK数据包丢失，则服务端或重新发送 FIN 包到客户端，而这两个过程的最长时间为 1MSL，加起来为 2MSL，如果 2MSL 后客户端还没有收到服务端重发的 FIN 包，则说明 ACK 包顺利到达，可以关闭连接了。




### TCP 长连接和短连接有什么区别？
TCP 短连接是指客户端与服务端连接后只进行一次读写就关闭连接，一般是客户端关闭。
而长连接则是指在进行完一次读写后不关闭连接，直到服务端压力过大则选择关闭一些长时间为进行读写的连接。

TCP 短连接的优点在于管理简单，而且不会对服务端造成太大的压力，而缺点是每次读写都需要连接耗时较长。

TCP 长连接的优点是可以迅速进行多次读写，缺点是对服务端压力大，且容易被恶意连接影响服务。

长短连接的区别就在于客户端和服务端选择的关闭策略不同，具体需要根据应用场景来选择合适的策略。