# 基本概念

- 进程是一个可拥有资源的独立单位；
- 线程程是一个调度和分派的基本单位。

## 为什么需要线程？
在多任务的环境下，需要进程间进行频繁的切换，会耗费很多时间，这就决定了进程的数目不能过多。

为了解决这个限制，将进程的两个属性分开：
- 线程作为独立调度和分派的基本单位，不同时作为占有资源的单位
- 进程作为拥有资源的基本单位，不对其进行频繁切换


在多线程操作系统中中，通常是在一个进程中包括多个线程，每个线程都是独立调度和分派的基本单位。

资源由进程来拥有，线程不拥有资源。

> - 同一个进程之间的线程切换不会导致进程的切换，只有不同进程间的线程切换才会导致进程切换。
> - 线程之间的切换所占用的资源比进程要少很多  线程的切换则仅需保存和设置少量寄存器内容，不会同进程切换需求创建和销毁进程控制块PCB等，所以非常迅速，所以其十分适合高并发环境。

总的来说就是为了更进一步提高系统的并发性,提高CPU的利用率.

## 简述进程通信的各种方法

进程间通信的方式通常分为管道、系统 IPC、套接字三种，其中管道有无名管道、命名管道，系统 IPC 有消息队列、信号、共享内存
- 管道
	- 无名管道的本质是在内核缓冲区的环形队列，每次读取数据后缓冲区都会移动，并且无名管道只能在有亲缘关系的进程间使用
	- 命名管道则以文件的形式存在，由于有一个路径名，使用没有亲缘关系的进程间也可以使用命名管道
- 系统IPC
	- 消息队列是存放在内核中的消息链表，
		- 具有特定的格式，
		- 支持多种数据类型，
		- 且允许多个进程进行读写
	- 信号是软件层次上对中断机制的一种模拟，
		- 是一种异步通信方式，
		- 可以在用户空间进程和内核之间直接交互
	- 共享内存顾名思义就是两个进行对同一块内存进行读写，
		- 是最快的 IPC 形式，
		- 但不适合大量的数据传输
- 套接字
	- Socket 是对 TCP/IP 协议族的封装，不仅可以用于本机上的进程间通信，更多的被用于网络通信中

## 线程间的通信

### 基于 _**volatile**_ 关键字来实现线程间相互通信

使用**共享内存**的思想

大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式

### wait()、notify()、notifyAll()

_Object_类提供了线程间通信的方法：_wait()_、_notify()_、_notifyaAll()_，它们是多线程通信的基础，而这种实现方式的思想自然是线程间通信。

> wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁

> **void notify()**   
Wakes up a single thread that is waiting on this object’s monitor.   
译：唤醒在此对象监视器上等待的单个线程
>**void notifyAll()**   
Wakes up all threads that are waiting on this object’s monitor.   
译：唤醒在此对象监视器上等待的所有线程
>**void wait( )**   
Causes the current thread to wait until another thread invokes the notify() method or the notifyAll( ) method for this object.   
译：导致当前的线程等待，直到其他线程调用此对象的notify( ) 方法或 notifyAll( ) 方法


- 当需要调用以上的方法的时候，一定要对竞争资源进行加锁
- 当想要调用wait( )进行线程等待时，必须要取得这个锁对象的控制权（对象监视器），一般是放到synchronized(obj)代码中
- 调用obj.wait( )释放了obj的锁，否则其他线程也无法获得obj的锁
- notify( )方法只会通知等待队列中的第一个相关线程（不会通知优先级比较高的线程）
- notifyAll( )通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）
- 假设有三个线程执行了obj.wait( )，那么obj.notifyAll( )则能全部唤醒tread1，thread2，thread3，但是要继续执行obj.wait（）的下一条语句，必须获得obj锁，因此，tread1，thread2，thread3只有一个有机会获得锁继续执行，例如tread1，其余的需要等待thread1释放obj锁之后才能继续执行。
- 当调用obj.notify/notifyAll后，调用线程依旧持有obj锁，因此，thread1，thread2，thread3虽被唤醒，但是仍无法获得obj锁。直到调用线程退出synchronized块，释放obj锁后，thread1，thread2，thread3中的一个才有机会获得锁继续执行。

### LockSupport

一种非常灵活的实现线程间阻塞和唤醒的工具，需要知道线程的名字


## 一个进程中有哪些资源

### 线程私有的
**线程上下文**：所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器

![](https://pic2.zhimg.com/80/v2-8f47a0f3a4c168c8dab0abe667b56dea_720w.jpg?source=1940ef5c)
### 线程共有的

#### 代码区

就是我们写的代码，**更准确的是编译后的可执行机器指令**。

线程之间共享代码区，**这就意味着程序中的任何一个函数都可以放到线程中去执行，不存在某个函数只能被特定线程执行的情况**。

#### 堆区

**只要知道变量的地址，也就是指针，任何一个线程都可以访问指针指向的数据**，因此堆区也是线程共享的属于进程的资源。

#### 文件

如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源。


## 简述进程切换的流程：

如果想要从A进程切换到 B 进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当 CPU 在用户进程手上的时候，他可以选择一直执行，不让出 CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用 CPU 的 A 进程，才能切换到 B 进程。

由于从用户态切换到内核态的时候，CPU 是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。

这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB (进程控制块)等。


## 进程的互斥和同步

在操作系统中，进程是占有资源的最小单位，对于那种只能同时被一个进程持有的资源我们称为临界资源，对于临界资源的访问，必须是互斥的。（对于；临界资源的访问过程分为：进入区、临界区、退出区、剩余区）

而进程之间访问临界资源时可以构成同步与互斥两种关系，同步即两个进程的资源访问必须是先后关系，比如经典的生产者消费者问题，读者写着问题。而互斥则是两种在进行资源抢到，比如购票问题。

通常在软件层面可以使用替换算法来实现，即每个进程持有一个标志，每次当使用资源时则将自己的标志与资源的标志互换，如果在互换的过程中发现自己获得的标志是正在使用的状态，则在此循环等待。这种方法的缺点在于每个进程都需要进行循环等待，比较低效。所以一般是通过硬件层面的信号量即PV操作来实现进程的临界资源管理。

## 线程池

### 什么是线程池？

JAVA中开辟出的管理线程的一个概念，作用是方便管理线程，节约内存资源。

### 为什么要线程池？

应用程序中我们要多次使用线程，那就要多次创建销毁线程，而创建销毁线程会消耗内存，为了节约内存资源，我们引入了线程池。

总结：
线程池的好处：
1. 降低资源消耗
2. 提高响应速度
3. 提高线程的可管理性


### 线程池创建的方式

Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：
1. newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。



## 线程、进程、协程

### 概念：
#### 进程：

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是系统进行资源分配与调度的一个独立单位。每个进程都有自己独立的内存空间，由于进程比较重量‘占据独立的内存，所以上下文进程的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但是相对也比较安全。

#### 线程：

线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中最小的单元，由于线程ID、程序计数器、寄存器集合、和堆栈共同组成。它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

#### 协程：

协程，又被称为微线程，一个线程可以拥有多个协程，协程拥有自己的寄存器上下文和栈。协程在执行过程中，可以进行中断，然后转区执行别的子程序，在适当的时候在返回来接着执行，注意：这个过程是在一个子程序中中断，去执行其他的子程序，不是函数调用，有点类似于CPU的中断。

**补充**： 

协程不是被操作系统内核所管理，而完全是由程序所控制（在用户态执行）

具体点说，协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换，所以， **协程的开销远远小于线程的开销**

### 进程与线程比较：
（1）线程是属于进程的，线程运行在进程空进内，同一进程所产生的线程共享同一内存空间。

（2）当进程退出时该进程所产生线程都会被强制退出并清除

（3）线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)

### 线程与协程比较：
（1）一个线程可以拥有多个协程。

（2）线程进程都是同步机制，而协程是异步。

（3）对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。所以协程的切换比线程方便。

（4）因为协程就是在一个线程内部，对于内存的操作不会出现冲突，向进程与线程那样对共享资源加锁，只需要程序在运行时判断状态即可。

