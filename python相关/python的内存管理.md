id() 函数可用来返回对象的内存地址

python主要包含三种垃圾回收器：
1. 引用计数回收器
2. 标记清除回收器
3. 世代回收器


# python对象内存模型


![PyObject对象内存模型](https://img-blog.csdn.net/20160827121011043)

图中可以看出：

一个PyObject必须包含： 
1. ob_refcnt  这个对象的**引用计数**
2. ob_type 指向_typeobject结构体的**指针**，即**类型信息**

**引用计数** 和 **类型信息** 这两者是Python中对象机制的核心


这边再补充一下 ob_type ，
它是指向_typeobject 结构体的指针， 是python内部的一种特殊对象
是用来制订一个对象类型的类型对象（翻译：它是个类型对象，用来指定对象的类型）
所以，上图中，它指向PyTypeObject

而，在PyTypeObject中，定义了大量函数指针，这些函数指针会指向某个函数，或者NULL

这些函数指针可以视为类型对象中所定义的操作，而这些操作直接决定着一个对象在运行时所表现出的行为。（这句话不好理解，看下面的例子）


## 定长对象（Fixed-sized）

定长对象有 None，Int，List 具体模型看下图：
![这里写图片描述](https://img-blog.csdn.net/20160827122436445)

从上图可以看出，None对象的模型和PyObject一致；
Int类型多了一个ob_ival，那么这个字段存储的就是int的值 value

> **问题一**：在Python中，List其实是一个可变长的，类似于C++中的vector的数据结构，为什么它的内存模型是定长的呢？
> 
> 答： 因为List的内存模型的字段，都是**元数据**，真正存放数组数据的是 ob_item指向的一个数组。

> **问题二**：在`PyListObject`对象中，有一个`ob_size`，而在最后为什么又有一个`allocated`，那么这两个变量之间的关系是什么呢？
> 
> `ob_size`和`allocated`都和`PyListObject`对象的内存管理有关，`PyListObject`所采用的内存管理策略和C++中的vector采取内存管理策略是一样的。
> 申请内存的时候，`PyListObject`会申请一大块区域，这个区域的大小就记录在allocated中
> 而实际使用的内存的大小记录在ob_size当中

## 变长对象

tuple

![`tuple`对象内存模型](https://img-blog.csdn.net/20160827121045130)

tuple在python使用时，是一个定长的list，而在PyObject中是一个变长对象。


string

![`string`对象内存模型](https://img-blog.csdn.net/20160827121053208)

在创建`PyStringObject`对象时，除了为`PyString_Object`申请内存，还有为字符数组内的元素申请额外的内存（绿色填充的字符数组内存）。

然后将hash缓存值设为-1，将参数str指向的字符数组内的字符拷贝到`PyStringObject`所维护的空间中，在拷贝过程中，将字符数组最后的`'\0'`字符也拷贝了。

# python的垃圾回收机制

## 引用计数

python垃圾回收 以引用计数为主，分代回收为辅，

引用技术法的原理是每个对象维护的ob_refcnt，用来记录每个对象被引用的次数，具体如下：

**+1 的情况：**
1. 对象被创建 a=10
2. 对象被引用 b=a
3. 对象被作为参数，传到函数中 func(a)
4. 对象作为一个元素，存储在容器中 list={a,'a',1}

**相应的，-1的情况：**
1. 该对象的别名被显式销毁 del a
2. 当该对象的引别名被赋予新的对象（a指向了新的值） a=26
3. 一个对象离开了它的作用域（例如func函数执行完毕，函数里的局部变量的引用计数器减一，但全局变量不会）
4. 元素被从容器中删除，或者容器被销毁

**当指向该对象的内存的引用计数器为0的时候，该内存将会被Python虚拟机销毁**


**引用计数法的优点：**
1. 高效
2. 实用性（运行期没有停顿）一旦没有引用，内存就直接释放了，不想其它机制还要等到特定时机。 处理回收内存的时间分摊到了平时。
3. 对象有确定的生命周期
4. 易于实现

**原始引用计数法的缺点：**
1. 维护引用计数法消耗资源
2. 无法解决循环引用的问题。

	A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。
	
为了解决上面的问题，python引入了下面两种GC机制

## 标记-清除

标记清除（Mark—Sweep）算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：

第一阶段是标记阶段，GC会把所有的活动对象打上标记，
第二阶段是把那些没有标记的对象非活动对象进行回收。

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。

从根对象（root object）出发，沿着有向边遍历对象，
- 可达的（reachable）对象标记为活动对象，
- 不可达的对象就是要被清除的非活动对象。

根对象就是全局变量、调用栈、寄存器。

标记清除算法作为Python的辅助垃圾收集技术，**主要处理的是一些容器对象**，比如list、dict、tuple等，因为对于字符串、数值对象是不可能造成循环引用问题。

这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。


## 分代回收

分代回收是**建立在标记清除技术基础之上的，是一种以空间换时间的操作方式**。

每次当你创建一个对象或其他什么值的时候，Python会将其加入零代链表
![](https://upload-images.jianshu.io/upload_images/311496-7c9e91a54318d569.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/580/format/webp)

从上边可以看到当我们创建ABC节点的时候，Python将其加入零代链表。请注意到这并**不是一个真正的列表**，并不能直接在你的代码中访问，事实上这个链表是一个完全内部的Python运行时。

相似的，当我们创建DEF节点的时候，Python将其加入同样的链表
![](https://upload-images.jianshu.io/upload_images/311496-22b239ca5974128f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/649/format/webp)

现在零代包含了两个节点对象。(他还将包含Python创建的每个其他值，与一些Python自己使用的内部值。)

### 检测循环引用

随后，Python会循环遍历零代列表上的每个对象，检查列表中每个互相引用的对象，根据规则减掉其引用计数。在这个过程中，Python会一个接一个的统计内部引用的数量以防过早地释放对象。


![](https://upload-images.jianshu.io/upload_images/311496-05e563a1ddcd9cd1.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/687/format/webp)

从上面可以看到 ABC 和 DEF 节点包含的引用数为1 有三个其他的对象同时存在于零代链表中，蓝色的箭头指示了有一些对象正在被零代链表之外的其他对象所引用。(接下来我们会看到，Python中同时存在另外两个分别被称为一代和二代的链表)。这些对象有着更高的引用计数因为它们正在被其他指针所指向着。

  ![](https://upload-images.jianshu.io/upload_images/311496-4da43891c8aaef04.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/688/format/webp)
  
  
1. 通过识别内部引用，Python能够减少许多零代链表对象的引用计数。

2. 在上图的第一行中你能够看见ABC和DEF的引用计数已经变为零了，这意味着收集器可以释放它们并回收内存空间了。

3. 剩下的活跃的对象则被移动到一个新的链表：一代链表。

  
  ### Python中的GC阈值

Python什么时候会进行这个标记过程？随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。


当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。

**一旦这个差异累计超过某个阈值**，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。


随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循**同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值**，Python会将剩下的活跃对象移动到二代列表。

通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。**Python处理零代最为频繁，其次是一代然后才是二代。**

### 弱代假说

来看看代垃圾回收算法的核心行为：垃圾回收器会更频繁的处理新对象。

一个新的对象即是你的程序刚刚创建的，而一个来的对象则是经过了几个时间周期之后仍然存在的对象。Python会在当一个对象从零代移动到一代，或是从一代移动到二代的过程中提升(promote)这个对象。

为什么要这么做？这种算法的根源来自于弱代假说(weak generational hypothesis)。这个假说由两个观点构成：
1. 首先是年青的对象通常死得也快，
2. 而老对象则很有可能存活更长的时间。